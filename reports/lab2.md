利用 `sys_write` 实现中的 `translated_byte_buffer`，实现向虚拟地址按字节连续写入一定数据的功能，进而恢复 `sys_get_time` 和 `sys_task_info`；在 `MemorySet` 中实现判断虚拟地址是否与给定地址重叠、取消一段虚拟地址的映射的功能，并在 `TASK_MANAGER` 中暴露相应接口，以实现 `mmap` 和 `munmap` 的弱化版本（仅考虑映射内存，且 `munmap` 只允许取消先前 `mmap` 映射的内存）。

# 问答题

1. SV39 页表页表项包括保留位、物理页号，以及标志位。标志位描述了页表项是否合法、对应虚拟页面是否可读/可写/可执行/是否在 U 态下可以访问、页表项在所有地址空间中是否有效、自从页表项上的这一位被清零之后页表项的对应虚拟页面是否被访问过/被修改过。

2. 异常 StoreFault、 StorePageFault、 LoadFault、 LoadPageFault 可能是由缺页导致的。发生缺页时，重要寄存器的值包括 `scause`、`stval`、`sepc`。
   
   采用 Lazy 策略可以提高内存利用效率、减小内存初始化开销、提高虚拟内存被分配的物理页面的连续性等。

   SV39 页表大约占用内存 20MiB（rCore-Tutorial-Book-v3 中的结论）。为实现 Lazy 策略，需要延迟物理内存的分配，只分配虚拟地址空间。对于缺页异常，需要额外判断给定的虚拟内存是否在合法范围内，如果访问有效需要分配物理页面并重新启动引发缺页异常的指令。

   此时 PTE 的 V 标志位为 0。

3. 单页表情况下，内核与用户程序共用同一张页表，只需在打开分页模式时切换一次页表。为控制用户态无法访问内核页面，需要在 PTE 中对应设置 U 标志位。相比于双页表，单页表有更简单更快的上下文切换效率、更少的内存开销。对于双页表实现，需要更换页表的时机包括用户态进入内核态、内核态返回用户态。

# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

2. 此外，我也参考了 **以下资料**，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   > [rCore-Tutorial-Book-v3 SV39 多级页表的硬件机制](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html)

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
